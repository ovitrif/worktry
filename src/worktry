#!/bin/bash

show_help() {
  cat << EOF
worktry - Run AI agents in parallel with git worktrees

USAGE:
  worktry init              Initialize repo for wt setup
  worktry go <name>         Navigate to worktree by branch name
  worktry back              Navigate back to main worktree
  worktry list              List all worktrees
  worktry new <name> [base] Create worktree directly (legacy)
  worktry -h, --help        Show this help message

FILES CREATED BY \`worktry init\`:
  worktrees.json            Config for wt setup command
  .worktree-setup.sh        Setup script (creates .claude/settings.local.json)
  .worktreekeep             List of files to copy to new worktrees (optional)

WORKFLOW:
  1. worktry init           # Initialize repo
  2. Edit .worktreekeep     # Add files to copy (e.g., .env, .idea/)
  3. wt setup feature -c    # Create worktree with setup
  4. worktry go feature     # Navigate to worktree
  5. worktry back           # Return to main repo

See: https://github.com/johnlindquist/worktree-cli
EOF
}

create_worktrees_json() {
  if [ -f "worktrees.json" ]; then
    echo "Error: worktrees.json already exists in current directory."
    echo "Remove it first or edit manually."
    exit 1
  fi

  # Create .worktreekeep template
  cat > .worktreekeep << 'KEEP_EOF'
# Files/directories to copy to new worktrees
# (one path per line, relative to repo root)
#
# Examples:
# .env
# local.properties
# .idea/
# keystore.properties
KEEP_EOF

  # Create setup script
  cat > .worktree-setup.sh << 'SETUP_EOF'
#!/bin/bash

# Create Claude Code settings
mkdir -p .claude
cat > .claude/settings.local.json << 'JSON_EOF'
{
  "permissions": {
    "allow": [
      "Bash",
      "Read",
      "Edit",
      "Write",
      "WebFetch",
      "mcp__ide__getDiagnostics",
      "WebSearch",
      "mcp__github__pull_request_read",
      "mcp__github__search_pull_requests",
      "mcp__github__list_pull_requests"
    ],
    "deny": [],
    "ask": [
      "Bash(rm -rf:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)"
    ],
    "additionalDirectories": [
      "/Users/ovitrif/repos"
    ]
  }
}
JSON_EOF

# Copy files listed in .worktreekeep
if [ -f "$ROOT_WORKTREE_PATH/.worktreekeep" ]; then
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
    # Trim whitespace
    line=$(echo "$line" | xargs)
    src="$ROOT_WORKTREE_PATH/$line"
    if [ -e "$src" ]; then
      # Create parent directory if needed
      mkdir -p "$(dirname "$line")"
      cp -r "$src" "$line"
      echo "  Copied: $line"
    fi
  done < "$ROOT_WORKTREE_PATH/.worktreekeep"
fi
SETUP_EOF
  chmod +x .worktree-setup.sh

  # Create worktrees.json
  cat > worktrees.json << 'EOF'
{
  "setup-worktree": [
    "bash $ROOT_WORKTREE_PATH/.worktree-setup.sh"
  ]
}
EOF

  echo "âœ“ Created worktrees.json, .worktree-setup.sh, and .worktreekeep"
  echo ""
  echo "Next steps:"
  echo "  1. Edit .worktreekeep to add files to copy (e.g., .env, .idea/)"
  echo "  2. wt setup <branch-name> -c    # Create worktree with setup"
}

create_worktree() {
  NAME=$1
  BASE_BRANCH=${2:-HEAD}

  if [ -z "$NAME" ]; then
    echo "Error: Name argument is required."
    echo "Usage: worktry new <NAME> [BASE_BRANCH]"
    exit 1
  fi

  PROJECT_NAME=$(basename "$PWD")
  TARGET_PATH="../${PROJECT_NAME}.${NAME}"

  echo "Creating worktree '$NAME' at '$TARGET_PATH' from '$BASE_BRANCH'..."
  git worktree add "$TARGET_PATH" -b "$NAME" "$BASE_BRANCH"
}

# Navigate to a worktree by branch name
go_to_worktree() {
  local name="$1"
  if [ -z "$name" ]; then
    echo "Error: Branch name required." >&2
    echo "Usage: worktry go <branch-name>" >&2
    exit 1
  fi

  # Find worktree path by branch name
  local path=$(git worktree list --porcelain 2>/dev/null | awk -v branch="$name" '
    /^worktree / { wt = substr($0, 10) }
    /^branch / { if ($0 ~ branch "$") print wt }
  ')

  if [ -z "$path" ]; then
    echo "Error: No worktree found for branch '$name'" >&2
    exit 1
  fi

  # Output path for shell function to cd
  echo "$path"
}

# Navigate back to main worktree
go_back() {
  # Main worktree is the one without "branch" being a linked worktree
  # It's typically the first one listed, or we find the one that's not bare
  local main_path=$(git worktree list --porcelain 2>/dev/null | awk '
    /^worktree / { wt = substr($0, 10) }
    /^bare$/ { next }
    /^HEAD / { if (wt) { print wt; exit } }
  ')

  if [ -z "$main_path" ]; then
    # Fallback: first worktree
    main_path=$(git worktree list 2>/dev/null | head -1 | awk '{print $1}')
  fi

  if [ -z "$main_path" ]; then
    echo "Error: Could not find main worktree" >&2
    exit 1
  fi

  echo "$main_path"
}

# Navigate to worktree by index (0 = main, 1-9 = linked worktrees)
go_to_index() {
  local index="$1"
  
  # Index 0 = main worktree
  if [ "$index" = "0" ]; then
    go_back
    return
  fi
  
  # Get worktree at index (1-based from linked worktrees, which start at line 2)
  local path=$(git worktree list 2>/dev/null | sed -n "$((index + 1))p" | awk '{print $1}')
  
  if [ -z "$path" ]; then
    echo "Error: No worktree at index $index" >&2
    echo "" >&2
    echo "Available worktrees:" >&2
    local i=0
    git worktree list 2>/dev/null | while IFS= read -r line; do
      echo "$i  $line" >&2
      ((i++))
    done
    echo "" >&2
    local total=$(git worktree list 2>/dev/null | wc -l | tr -d ' ')
    echo "wt setup feature -c    # Create worktree with setup" >&2
    echo "It will be available as: worktry $total" >&2
    exit 1
  fi
  
  echo "$path"
}

# List worktrees with index prefix
list_indexed() {
  local i=0
  git worktree list 2>/dev/null | while IFS= read -r line; do
    echo "$i  $line"
    ((i++))
  done
}

# Edit .worktreekeep file
edit_worktreekeep() {
  local keepfile=".worktreekeep"
  
  # Create file if it doesn't exist
  if [ ! -f "$keepfile" ]; then
    cat > "$keepfile" << 'KEEP_EOF'
# Files/directories to copy to new worktrees
# (one path per line, relative to repo root)
#
# Examples:
# .env
# local.properties
# .idea/
# keystore.properties
KEEP_EOF
    echo "Created $keepfile"
  fi

  # Check for editor
  local editor="${EDITOR:-${VISUAL:-}}"
  
  if [ -n "$editor" ]; then
    $editor "$keepfile"
  else
    echo "No default text editor configured."
    echo ""
    echo "To set one, add to your shell config (~/.zshrc or ~/.bashrc):"
    echo "  export EDITOR=nano      # or vim, subl, code, etc."
    echo ""
    read -p "Open with VSCode instead? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      echo ""
      echo "Note: This assumes VSCode is installed and the 'code' command"
      echo "      is available in your PATH."
      echo ""
      code "$keepfile"
    fi
  fi
}

case "$1" in
  init|i)
    create_worktrees_json
    ;;
  go)
    go_to_worktree "$2"
    ;;
  back|b)
    go_back
    ;;
  list|ls|l)
    git worktree list
    ;;
  keep|k)
    edit_worktreekeep
    ;;
  new|n)
    create_worktree "$2" "$3"
    ;;
  -h|--help|"")
    show_help
    ;;
  [0-9])
    go_to_index "$1"
    ;;
  *)
    echo "Error: Unknown command '$1'"
    echo ""
    show_help
    exit 1
    ;;
esac
