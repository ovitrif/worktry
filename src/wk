#!/bin/bash

show_help() {
  cat << EOF
██╗     ██╗                   ██╗   ██████████╗
██║     ██║                   ██║   ╚═══██╔═══╝
██║ ██╗ ██║  ██████╗  ██████╗ ██║ ██╗   ██║  ██████╗ ██╗   ██╗
██║████╗██║ ██╚═══██║ ██╔═══╝ █████╔╝   ██║  ██╔═══╝  ██╗ ██╔╝
 ███║ ███╔╝  ██████╔╝ ██║     ██╔═██╗   ██║  ██║       ████╔╝
 ╚══╝ ╚══╝   ╚═════╝  ╚═╝     ╚═╝ ╚═╝   ╚═╝  ╚═╝        ██╔╝
 ██ Vibe code in parallel using git worktrees or clones ██║
 █████████████████████████████████████████████████████████║
 ╚════════════════════════════════════════════════════════╝

USAGE:
wk <command> [options]
wk <0-9>                        Quick navigation by index

COMMANDS:
init, i                   Initialize repo for wk
list, ls, l               List worktrees or clones
go <name>                 Navigate to worktree by branch name
back, b                   Navigate back to main worktree
config, c                 Edit worktrees.json config
setup <dir>               Apply wk setup to a clone
new <name> [-b BASE]      Create worktree with setup
-h, --help                Show this help

NAVIGATION:
wk 0                      Jump to main repo
wk 1                      Jump to first worktree/clone
wk 2-9                    Jump to 2nd-9th worktree/clone

FILES:
worktrees.json            Config for wt setup + copy-over list
.worktree-setup.sh        Setup script (Claude permissions, file copying)

ALIAS: worktry

See: https://github.com/ovitrif/worktry
EOF
}

create_worktrees_json() {
  if [ -f "worktrees.json" ]; then
    echo "Error: worktrees.json already exists in current directory."
    echo "Remove it first or edit manually."
    exit 1
  fi

  # Create setup script
  cat > .worktree-setup.sh << 'SETUP_EOF'
#!/bin/bash

# Create Claude Code settings
mkdir -p .claude
cat > .claude/settings.local.json << 'JSON_EOF'
{
  "permissions": {
    "allow": [
      "Bash",
      "Read",
      "Edit",
      "Write",
      "WebFetch",
      "mcp__ide__getDiagnostics",
      "WebSearch",
      "mcp__github__pull_request_read",
      "mcp__github__search_pull_requests",
      "mcp__github__list_pull_requests"
    ],
    "deny": [],
    "ask": [
      "Bash(rm -rf:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)"
    ],
    "additionalDirectories": [
      "/Users/ovitrif/repos"
    ]
  }
}
JSON_EOF

# Copy files from copy-over array in worktrees.json
if [ -f "$ROOT_WORKTREE_PATH/worktrees.json" ]; then
  # Parse copy-over array using simple grep/sed (no jq dependency)
  copy_items=$(grep -A 100 '"copy-over"' "$ROOT_WORKTREE_PATH/worktrees.json" | \
    grep -oE '"[^"]+"' | tr -d '"' | grep -v 'copy-over')
  
  for item in $copy_items; do
    src="$ROOT_WORKTREE_PATH/$item"
    if [ -e "$src" ]; then
      mkdir -p "$(dirname "$item")"
      cp -r "$src" "$item"
      echo "  Copied: $item"
    fi
  done
fi
SETUP_EOF
  chmod +x .worktree-setup.sh

  # Create worktrees.json with copy-over array
  cat > worktrees.json << 'EOF'
{
  "setup-worktree": [
    "bash $ROOT_WORKTREE_PATH/.worktree-setup.sh"
  ],
  "copy-over": [
  ]
}
EOF

  echo "✓ Created worktrees.json and .worktree-setup.sh"
  echo ""
  echo "Next steps:"
  echo "  1. wk config                    # Add files to copy-over list"
  echo "  2. wt setup <branch-name> -c    # Create worktree with setup"
}

create_worktree() {
  local name=""
  local base_branch="HEAD"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --base|-b)
        base_branch="$2"
        shift 2
        ;;
      *)
        if [ -z "$name" ]; then
          name="$1"
        else
          echo "Error: Unknown argument '$1'" >&2
          echo "Usage: wk new <NAME> [--base|-b BASE_BRANCH]" >&2
          exit 1
        fi
        shift
        ;;
    esac
  done

  if [ -z "$name" ]; then
    echo "Error: Name argument is required."
    echo "Usage: wk new <NAME> [--base|-b BASE_BRANCH]"
    exit 1
  fi

  PROJECT_NAME=$(basename "$PWD")
  TARGET_PATH="../${PROJECT_NAME}.${name}"

  echo "Creating worktree '$name' at '$TARGET_PATH' from '$base_branch'..."
  git worktree add "$TARGET_PATH" -b "$name" "$base_branch"
  
  # Run setup if .worktree-setup.sh exists
  if [ -f ".worktree-setup.sh" ]; then
    echo "Running setup..."
    (cd "$TARGET_PATH" && ROOT_WORKTREE_PATH="$PWD/.." bash "$PWD/../.worktree-setup.sh")
  fi
}

# Navigate to a worktree by branch name
go_to_worktree() {
  local name="$1"
  if [ -z "$name" ]; then
    echo "Error: Branch name required." >&2
    echo "Usage: wk go <branch-name>" >&2
    exit 1
  fi

  # Find worktree path by branch name
  local path=$(git worktree list --porcelain 2>/dev/null | awk -v branch="$name" '
    /^worktree / { wt = substr($0, 10) }
    /^branch / { if ($0 ~ branch "$") print wt }
  ')

  if [ -z "$path" ]; then
    echo "Error: No worktree found for branch '$name'" >&2
    exit 1
  fi

  # Output path for shell function to cd
  echo "$path"
}

# Navigate back to main worktree
go_back() {
  # Main worktree is the one without "branch" being a linked worktree
  # It's typically the first one listed, or we find the one that's not bare
  local main_path=$(git worktree list --porcelain 2>/dev/null | awk '
    /^worktree / { wt = substr($0, 10) }
    /^bare$/ { next }
    /^HEAD / { if (wt) { print wt; exit } }
  ')

  if [ -z "$main_path" ]; then
    # Fallback: first worktree
    main_path=$(git worktree list 2>/dev/null | head -1 | awk '{print $1}')
  fi

  if [ -z "$main_path" ]; then
    echo "Error: Could not find main worktree" >&2
    exit 1
  fi

  echo "$main_path"
}

# Check if in clone mode (no linked worktrees, but sibling clones exist)
is_clone_mode() {
  local wt_count=$(git worktree list 2>/dev/null | wc -l | tr -d ' ')
  # Clone mode if only 1 worktree (main) exists
  [[ "$wt_count" -le 1 ]]
}

# List sibling clone directories (same repo name prefix)
list_clones() {
  local current_dir=$(pwd)
  local parent_dir=$(dirname "$current_dir")
  local base_name=$(basename "$current_dir")
  
  # Remove any suffix like -2, -3, .feature to get base name
  base_name=$(echo "$base_name" | sed -E 's/[-.]?[0-9]+$//' | sed -E 's/\.[^.]+$//')
  
  # Find all directories matching base_name* that are git repos, sorted
  local clones=()
  while IFS= read -r dir; do
    if [[ -d "$dir/.git" || -f "$dir/.git" ]]; then
      clones+=("$dir")
    fi
  done < <(find "$parent_dir" -maxdepth 1 -type d -name "${base_name}*" 2>/dev/null | sort)
  
  printf '%s\n' "${clones[@]}"
}

# Navigate to worktree/clone by index (0 = main, 1-9 = others)
go_to_index() {
  local index="$1"
  
  if is_clone_mode; then
    # Clone mode: navigate by clone index
    local clones=()
    while IFS= read -r line; do
      [[ -n "$line" ]] && clones+=("$line")
    done < <(list_clones)
    
    if [[ $index -ge ${#clones[@]} ]]; then
      echo "Error: No clone at index $index" >&2
      echo "" >&2
      echo "Available clones:" >&2
      local i=0
      for clone in "${clones[@]}"; do
        echo "$i  $clone" >&2
        ((i++))
      done
      exit 1
    fi
    
    echo "${clones[$index]}"
  else
    # Worktree mode
    if [ "$index" = "0" ]; then
      go_back
      return
    fi
    
    local path=$(git worktree list 2>/dev/null | sed -n "$((index + 1))p" | awk '{print $1}')
    
    if [ -z "$path" ]; then
      echo "Error: No worktree at index $index" >&2
      echo "" >&2
      echo "Available worktrees:" >&2
      local i=0
      git worktree list 2>/dev/null | while IFS= read -r line; do
        echo "$i  $line" >&2
        ((i++))
      done
      echo "" >&2
      local total=$(git worktree list 2>/dev/null | wc -l | tr -d ' ')
      echo "wt setup feature -c    # Create worktree with setup" >&2
      echo "It will be available as: wk $total" >&2
      exit 1
    fi
    
    echo "$path"
  fi
}

# List worktrees or clones with index prefix
list_indexed() {
  if is_clone_mode; then
    local i=0
    while IFS= read -r clone; do
      [[ -n "$clone" ]] && echo "$i  $clone" && ((i++))
    done < <(list_clones)
  else
    local i=0
    git worktree list 2>/dev/null | while IFS= read -r line; do
      echo "$i  $line"
      ((i++))
    done
  fi
}

# Apply worktry setup to an existing clone directory
setup_clone() {
  local target_dir="$1"
  
  if [ -z "$target_dir" ]; then
    echo "Error: Directory argument required." >&2
    echo "Usage: wk setup <directory>" >&2
    exit 1
  fi
  
  # Resolve to absolute path
  if [[ ! "$target_dir" = /* ]]; then
    target_dir="$(pwd)/$target_dir"
  fi
  
  if [ ! -d "$target_dir" ]; then
    echo "Error: Directory '$target_dir' does not exist." >&2
    exit 1
  fi
  
  if [ ! -d "$target_dir/.git" ] && [ ! -f "$target_dir/.git" ]; then
    echo "Error: '$target_dir' is not a git repository." >&2
    exit 1
  fi
  
  local source_dir=$(pwd)
  
  if [ ! -f "$source_dir/.worktree-setup.sh" ]; then
    echo "Error: No .worktree-setup.sh in current directory." >&2
    echo "Run 'wk init' first." >&2
    exit 1
  fi
  
  echo "Applying wk setup to $target_dir..."
  (cd "$target_dir" && ROOT_WORKTREE_PATH="$source_dir" bash "$source_dir/.worktree-setup.sh")
  echo "✓ Setup complete"
}

# Edit worktrees.json config file
edit_config() {
  local configfile="worktrees.json"
  
  if [ ! -f "$configfile" ]; then
    echo "Error: $configfile not found." >&2
    echo "Run 'wk init' first." >&2
    exit 1
  fi

  local editor="${EDITOR:-${VISUAL:-}}"
  
  if [ -n "$editor" ]; then
    $editor "$configfile"
  else
    echo "No default text editor configured."
    echo ""
    echo "To set one, add to your shell config (~/.zshrc or ~/.bashrc):"
    echo "  export EDITOR=nano      # or vim, subl, code, etc."
    echo ""
    read -p "Open with VSCode instead? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      code "$configfile"
    fi
  fi
}

case "$1" in
  init|i)
    create_worktrees_json
    ;;
  go)
    go_to_worktree "$2"
    ;;
  back|b)
    go_back
    ;;
  list|ls|l)
    list_indexed
    ;;
  config|c)
    edit_config
    ;;
  setup|s)
    setup_clone "$2"
    ;;
  new|n)
    shift
    create_worktree "$@"
    ;;
  -h|--help|"")
    show_help
    ;;
  [0-9])
    go_to_index "$1"
    ;;
  *)
    echo "Error: Unknown command '$1'"
    echo ""
    show_help
    exit 1
    ;;
esac
